
import pandas as pd
import numpy as np
import sys
import os
import queue
from datetime import time, datetime

# Ensure we can import the backtesting package
sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

from backtesting.strategy import Strategy
from backtesting.schema import Bar, SignalType
from backtesting.data import SmartDataHandler
from backtesting.portfolio import Portfolio
from backtesting.execution import SimulatedExecutionHandler, FixedCommission
from backtesting.engine import BacktestEngine
from backtesting.performance import TearSheet

class CleanOrb5m(Strategy):
    """
    Gold Standard ORB Strategy (5m Execution).
    Designed for NQ/ES Futures.
    
    Logic:
    1. Identify Range (09:30-09:45) using 5m bars.
    2. Filter with EMA Trend and ADX Volatility.
    3. Enter on Breakout (5m Close).
    4. Manage with ATR Risk.
    """
    def __init__(self, bars, events, 
                 orb_start_time=time(9, 30), 
                 orb_end_time=time(9, 45),
                 exit_time=time(15, 45),
                 sl_atr_mult=2.0,
                 tp_atr_mult=4.0,
                 ema_filter=50,
                 atr_filter=14,
                 adx_filter=20,
                 atr_max_mult=2.5,
                 verbose=True):
                 
        self.PINE_TEMPLATE = """
// This Pine Script was AUTO-GENERATED by the StrategyPipeline
// Strategy: CleanOrb5m (Evidence Based)

//@version=5
strategy("NQ/ES 5m ORB [Evidence]", overlay=true, margin_long=100, margin_short=100, currency=currency.USD)

// --- optimized inputs ---
sl_atr_mult = input.float({{ sl_atr_mult }}, "SL ATR Mult")
tp_atr_mult = input.float({{ tp_atr_mult }}, "TP ATR Mult")
ema_period = input.int({{ ema_filter }}, "Trend EMA")
adx_threshold = input.float({{ adx_filter }}, "ADX Threshold")
atr_max = input.float({{ atr_max_mult }}, "Max Range Checks (ATR)")

// --- Time Settings ---
orb_start_hour = 9
orb_start_minute = 30
orb_end_hour = 9
orb_end_minute = 45

// --- Logic ---
t = time(timeframe.period, "0930-1600")
is_session = not na(t)

// Indicators
ema_val = ta.ema(close, ema_period)
[diplus, diminus, adx_val] = ta.dmi(14, 14)
atr_val = ta.atr(14)

// ORB Range
var float orb_high = na
var float orb_low = na

if (hour == orb_start_hour and minute == orb_start_minute)
    orb_high := high
    orb_low := low
else if (hour == orb_start_hour and minute >= orb_start_minute and minute < orb_end_minute)
    orb_high := math.max(orb_high, high)
    orb_low := math.min(orb_low, low)

// Reset Daily
if ta.change(time("D"))
    orb_high := na
    orb_low := na

plot(orb_high, "Range High", color=color.green, style=plot.style_stepline)
plot(orb_low, "Range Low", color=color.red, style=plot.style_stepline)
plot(ema_val, "EMA", color=color.yellow)

// Entry Conditions
range_size = orb_high - orb_low
is_compressed = range_size < (atr_val * atr_max)
has_adx = adx_val > adx_threshold

long_cond = close > orb_high and close > ema_val and has_adx and is_compressed and is_session and strategy.position_size == 0
short_cond = close < orb_low and close < ema_val and has_adx and is_compressed and is_session and strategy.position_size == 0

// Execution
if (long_cond)
    strategy.entry("Long", strategy.long)
    strategy.exit("Exit Long", "Long", stop=close - (atr_val * sl_atr_mult), limit=close + (atr_val * tp_atr_mult))

if (short_cond)
    strategy.entry("Short", strategy.short)
    strategy.exit("Exit Short", "Short", stop=close + (atr_val * sl_atr_mult), limit=close - (atr_val * tp_atr_mult))

// EOD Flatten
if (hour == 15 and minute == 45)
    strategy.close_all(comment="EOD")
"""
        super().__init__(bars, events)
        self.orb_start = orb_start_time
        self.orb_end = orb_end_time
        self.exit_time = exit_time
        self.verbose = verbose
        
        # State
        self.orb_high = None
        self.orb_low = None
        self.current_date = None
        self.traded_today = False
        
        self.entry_price = None
        self.in_long = False
        self.in_short = False
        self.current_sl = 0
        self.current_tp = 0
        
        # Params
        self.sl_atr_mult = float(sl_atr_mult)
        self.tp_atr_mult = float(tp_atr_mult)
        self.ema_filter = int(ema_filter)
        self.atr_filter = int(atr_filter)
        self.adx_filter = float(adx_filter)
        self.atr_max_mult = float(atr_max_mult)

    def calculate_signals(self, event: Bar):
        symbol = event.symbol
        ts = event.timestamp
        current_time = ts.time()
        
        # 1. Reset Daily
        if self.current_date != ts.date():
            self.current_date = ts.date()
            self.orb_high = -float('inf')
            self.orb_low = float('inf')
            self.traded_today = False
            self.entry_price = None
            self.in_long = False
            self.in_short = False

        # 2. Build Range (9:30-9:45)
        if self.orb_start <= current_time < self.orb_end:
            self.orb_high = max(self.orb_high, event.high)
            self.orb_low = min(self.orb_low, event.low)
            return

        # 3. Indicators (Need History)
        lookback = max(self.ema_filter, self.atr_filter) + 5
        bars = self.bars.get_latest_bars(symbol, N=lookback)
        if len(bars) < lookback: return
        
        from src.backtesting import ta
        df = pd.DataFrame([{'close': b.close, 'high': b.high, 'low': b.low} for b in bars])
        
        ema = ta.ema(df['close'], length=self.ema_filter).iloc[-1]
        atr = ta.atr(df['high'], df['low'], df['close'], length=self.atr_filter).iloc[-1]
        
        # 4. Entry Logic (9:45 - 15:45)
        if self.orb_end <= current_time < self.exit_time:
            if not self.traded_today:
                range_size = self.orb_high - self.orb_low
                is_compressed = range_size <= (atr * self.atr_max_mult)
                
                # Valid Range Check
                if self.orb_high == -float('inf'): return 

                # Long
                if event.close > self.orb_high and event.close > ema and is_compressed:
                     if self.verbose: 
                         print(f"[{ts}] LONG ENTRY @ {event.close}")
                     self.buy(symbol, 1)
                     self.traded_today = True
                     self.in_long = True
                     self.entry_price = event.close
                     self.current_sl = atr * self.sl_atr_mult
                     self.current_tp = atr * self.tp_atr_mult
                
                # Short
                elif event.close < self.orb_low and event.close < ema and is_compressed:
                     if self.verbose:
                         print(f"[{ts}] SHORT ENTRY @ {event.close}")
                     self.sell(symbol, 1)
                     self.traded_today = True
                     self.in_short = True
                     self.entry_price = event.close
                     self.current_sl = atr * self.sl_atr_mult
                     self.current_tp = atr * self.tp_atr_mult

            # 5. Management
            elif self.in_long:
                 if event.low < (self.entry_price - self.current_sl):
                     self.exit(symbol)
                     self.in_long = False
                 elif event.high > (self.entry_price + self.current_tp):
                     self.exit(symbol)
                     self.in_long = False
            elif self.in_short:
                 if event.high > (self.entry_price + self.current_sl):
                     self.exit(symbol)
                     self.in_short = False
                 elif event.low < (self.entry_price - self.current_tp):
                     self.exit(symbol)
                     self.in_short = False

        # 6. EOD
        if current_time >= self.exit_time:
            if self.in_long or self.in_short:
                self.exit(symbol)
                self.in_long = False
                self.in_short = False
