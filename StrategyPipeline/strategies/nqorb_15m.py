import pandas as pd
import numpy as np
import sys
import os
import queue
from datetime import time, datetime

# Ensure we can import the backtesting package
sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

from backtesting.strategy import Strategy
from backtesting.schema import Bar, SignalType
from backtesting.data import SmartDataHandler
from backtesting.portfolio import Portfolio
from backtesting.execution import SimulatedExecutionHandler, FixedCommission
from backtesting.engine import BacktestEngine
from backtesting.performance import TearSheet

class NqOrb15m(Strategy):
    """
    15-Minute Opening Range Breakout (ORB) for NQ Futures on 15m Timeframe.
    
    Hypothesis:
    The first 15 minutes (9:30-9:45 ET) establishes key support/resistance.
    Breakouts from this range with trend alignment produce profitable moves.
    Using 15m bars provides cleaner signals and reduces noise.
    """
    def __init__(self, bars, events, 
                 orb_start_time=time(9, 30), 
                 orb_end_time=time(9, 45),
                 exit_time=time(15, 45),
                 sl_atr_mult=2.0,
                 tp_atr_mult=4.0,
                 ema_filter=50,
                 atr_filter=14,
                 atr_max_mult=2.5,
                 verbose=True):
                 
        self.PINE_TEMPLATE = """
// This Pine Script was AUTO-GENERATED by the StrategyPipeline
// Optimized Settings included.

//@version=5
strategy("NQ ORB 15m [Auto]", overlay=true, margin_long=100, margin_short=100)

// --- Inputs (Optimized) ---
sl_atr_mult = input.float({{ sl_atr_mult }}, "SL ATR Mult")
tp_atr_mult = input.float({{ tp_atr_mult }}, "TP ATR Mult")
ema_period = input.int({{ ema_filter }}, "Regime EMA")
adx_thresh = input.float(20.0, "ADX Threshold")
orb_start_hour = 9
orb_start_minute = 30
orb_end_hour = 9
orb_end_minute = 45

// --- Logic ---
// 1. Session Logic
t = time(timeframe.period, "0930-1600")
is_session = not na(t)

// 2. ORB Range
var float orb_high = na
var float orb_low = na

if (hour == orb_start_hour and minute == orb_start_minute)
    orb_high := high
    orb_low := low
else if (hour == orb_start_hour and minute >= orb_start_minute and minute < orb_end_minute)
    orb_high := math.max(orb_high, high)
    orb_low := math.min(orb_low, low)

// Reset daily
if ta.change(time("D"))
    orb_high := na
    orb_low := na

plot(orb_high, "ORB High", color=color.green, style=plot.style_stepline)
plot(orb_low, "ORB Low", color=color.red, style=plot.style_stepline)

// 3. Indicators
ema_val = ta.ema(close, ema_period)
atr_val = ta.atr(14)
plot(ema_val, "EMA", color=color.yellow)

// 4. Entry
long_cond = close > orb_high and close > ema_val and strategy.position_size == 0 and is_session
short_cond = close < orb_low and close < ema_val and strategy.position_size == 0 and is_session

if (long_cond)
    strategy.entry("Long", strategy.long)
    strategy.exit("Exit Long", "Long", stop=close - (atr_val * sl_atr_mult), limit=close + (atr_val * tp_atr_mult))

if (short_cond)
    strategy.entry("Short", strategy.short)
    strategy.exit("Exit Short", "Short", stop=close + (atr_val * sl_atr_mult), limit=close - (atr_val * tp_atr_mult))

// 5. EOD Flatten
if (hour == 15 and minute == 45)
    strategy.close_all("EOD")
"""
        super().__init__(bars, events)
        self.orb_start = orb_start_time
        self.orb_end = orb_end_time
        self.exit_time = exit_time
        self.verbose = verbose
        
        # State tracking
        self.orb_high = None
        self.orb_low = None
        self.current_date = None
        self.traded_today = False
        self.entry_price = None
        self.in_long = False
        self.in_short = False
        self.current_sl = 0
        self.current_tp = 0
        
        # Strategy Parameters
        self.sl_atr_mult = float(sl_atr_mult)
        self.tp_atr_mult = float(tp_atr_mult)
        self.ema_filter = int(ema_filter)
        self.atr_filter = int(atr_filter)
        self.atr_max_mult = float(atr_max_mult)

    def calculate_signals(self, event: Bar):
        symbol = event.symbol
        ts = event.timestamp
        current_time = ts.time()
        
        # 1. Daily State Management
        if self.current_date != ts.date():
            self.current_date = ts.date()
            self.orb_high = -float('inf')
            self.orb_low = float('inf')
            self.traded_today = False
            self.entry_price = None
            self.in_long = False
            self.in_short = False

        # 2. Define the 15-Minute Range (09:30 - 09:45)
        # On 15m bars, this is typically just the first bar of the day
        if self.orb_start <= current_time < self.orb_end:
            self.orb_high = max(self.orb_high, event.high)
            self.orb_low = min(self.orb_low, event.low)
            return

        # 3. Indicator Calculation
        lookback = max(self.ema_filter, self.atr_filter) + 5
        bars = self.bars.get_latest_bars(symbol, N=lookback)
        if len(bars) < lookback:
            return
            
        df = pd.DataFrame([{
            'close': b.close, 'high': b.high, 'low': b.low, 'open': b.open
        } for b in bars])
        
        # Use local TA library
        from src.backtesting import ta

        ema = ta.ema(df['close'], length=self.ema_filter).iloc[-1]
        atr = ta.atr(df['high'], df['low'], df['close'], length=self.atr_filter).iloc[-1]

        # 4. Execution Window (09:45 - 15:45)
        if self.orb_end <= current_time < self.exit_time:
            if not self.traded_today:
                # Entry Logic with Filters
                range_size = self.orb_high - self.orb_low
                
                # Long: Price > Range High AND Close > EMA AND Range is not too wide
                if self.orb_high != -float('inf') and self.orb_low != float('inf'):
                    range_size = self.orb_high - self.orb_low
                    
                    if event.close > self.orb_high and event.close > ema:
                        if range_size <= (atr * self.atr_max_mult):
                            if self.verbose:
                                print(f"[{ts}] NQ 15m ORB LONG ENTRY @ {event.close} | EMA: {ema:.2f}, Range: {range_size:.1f}")
                            self.buy(symbol, quantity=1)
                            self.traded_today = True
                            self.in_long = True
                            self.entry_price = event.close
                            self.current_sl = atr * self.sl_atr_mult
                            self.current_tp = atr * self.tp_atr_mult
                    
                    # Short: Price < Range Low AND Close < EMA AND Range is not too wide
                    elif event.close < self.orb_low and event.close < ema:
                        if range_size <= (atr * self.atr_max_mult):
                            if self.verbose:
                                print(f"[{ts}] NQ 15m ORB SHORT ENTRY @ {event.close} | EMA: {ema:.2f}, Range: {range_size:.1f}")
                            self.sell(symbol, quantity=1)
                            self.traded_today = True
                            self.in_short = True
                            self.entry_price = event.close
                            self.current_sl = atr * self.sl_atr_mult
                            self.current_tp = atr * self.tp_atr_mult
            
            elif self.in_long or self.in_short:
                # 5. Risk Management
                if self.in_long:
                    if event.low < (self.entry_price - self.current_sl):
                        if self.verbose:
                            print(f"[{ts}] NQ STOP LOSS (LONG) @ {event.low}")
                        self.exit(symbol)
                        self.in_long = False
                    elif event.high > (self.entry_price + self.current_tp):
                        if self.verbose:
                            print(f"[{ts}] NQ TAKE PROFIT (LONG) @ {event.high}")
                        self.exit(symbol)
                        self.in_long = False
                elif self.in_short:
                    if event.high > (self.entry_price + self.current_sl):
                        if self.verbose:
                            print(f"[{ts}] NQ STOP LOSS (SHORT) @ {event.high}")
                        self.exit(symbol)
                        self.in_short = False
                    elif event.low < (self.entry_price - self.current_tp):
                        if self.verbose:
                            print(f"[{ts}] NQ TAKE PROFIT (SHORT) @ {event.low}")
                        self.exit(symbol)
                        self.in_short = False

        # 5. End of Session Flatten (15:45)
        if current_time >= self.exit_time:
            if self.in_long or self.in_short:
                if self.verbose:
                    print(f"[{ts}] SESSION END: Liquidating Position.")
                self.exit(symbol)
                self.in_long = False
                self.in_short = False

if __name__ == "__main__":
    # Settings for NQ Intraday on 15m timeframe
    symbol_list = ['NQ']
    interval = '15m'  # 15-minute bars
    data_dir = r"C:\Users\User\Desktop\Portfolio\OHLC\Intra OHLC"
    
    events = queue.Queue()
    data = SmartDataHandler(symbol_list, search_dirs=[data_dir], interval=interval)
    
    # NQ Multiplier is $20 per point
    instruments = {'NQ': {'multiplier': 20.0}}
    portfolio = Portfolio(data, events, initial_capital=250000.0, instruments=instruments)
    
    strategy = NqOrb15m(data, events)
    execution = SimulatedExecutionHandler(events, data, commission_model=FixedCommission(1.0))
    
    engine = BacktestEngine(data, strategy, portfolio, execution)
    engine.run()
    
    tearsheet = TearSheet(portfolio)
    tearsheet.analyze()
