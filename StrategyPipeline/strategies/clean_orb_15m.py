
import pandas as pd
import numpy as np
import sys
import os
import queue
from datetime import time, datetime

# Ensure we can import the backtesting package
sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

from backtesting.strategy import Strategy
from backtesting.schema import Bar, SignalType
from backtesting.data import SmartDataHandler
from backtesting.portfolio import Portfolio
from backtesting.execution import SimulatedExecutionHandler, FixedCommission
from backtesting.engine import BacktestEngine
from backtesting.performance import TearSheet

class CleanOrb15m(Strategy):
    """
    Gold Standard 15m ORB Strategy.
    Designed for NQ Futures.
    
    Logic:
    1. Identify Range (09:30-09:45).
    2. Filter with EMA Trend and ADX Volatility.
    3. Enter on Breakout.
    4. Manage with ATR Risk.
    """
    def __init__(self, bars, events, 
                 orb_start_time=time(9, 30), 
                 orb_end_time=time(9, 45),
                 exit_time=time(15, 45),
                 sl_atr_mult=2.5,
                 tp_atr_mult=5.0,
                 ema_filter=50,
                 atr_filter=14,
                 adx_filter=20,
                 atr_max_mult=3.0,
                 use_adx=True, # Added for WFO compatibility
                 adx_thresh=20, # Added for WFO compatibility
                 use_macro_filter=False, # New Regime Filter
                 use_rvol=False, # New Regime Filter
                 rvol_thresh=1.5,
                 verbose=False):
                 
        self.PINE_TEMPLATE = """
// This Pine Script was AUTO-GENERATED by the StrategyPipeline
// Strategy: CleanOrb15m (Optimized)

//@version=5
strategy("NQ 15m ORB [Clean]", overlay=true, margin_long=100, margin_short=100, currency=currency.USD, commission_type=strategy.commission.cash_per_contract, commission_value=2.05, slippage=0)

// --- Optimized Inputs ---
sl_atr_mult = input.float({{ sl_atr_mult }}, "SL ATR Mult")
tp_atr_mult = input.float({{ tp_atr_mult }}, "TP ATR Mult")
ema_period = input.int({{ ema_filter }}, "Trend EMA")
adx_threshold = input.float({{ adx_filter }}, "ADX Threshold")
atr_max = input.float({{ atr_max_mult }}, "Max Range Checks (ATR)")
use_macro_filter = input.bool({{ use_macro_filter }}, "Use Macro Trend Filter (Daily SMA 200)")
use_rvol = input.bool({{ use_rvol }}, "Use RVOL Filter")
rvol_thresh = input.float({{ rvol_thresh }}, "RVOL Threshold")

// --- Time Settings ---
orb_start_hour = 9
orb_start_minute = 30
orb_end_hour = 9
orb_end_minute = 45

// --- Logic ---
t = time(timeframe.period, "0930-1600")
is_session = not na(t)

// Indicators
ema_val = ta.ema(close, ema_period)
[diplus, diminus, adx_val] = ta.dmi(14, 14)
atr_val = ta.atr(14)
// Macro Trend
daily_sma = request.security(syminfo.tickerid, "D", ta.sma(close, 200))
macro_trend_ok = not use_macro_filter or (close > daily_sma)

// RVOL
vol_ma = ta.sma(volume, 20)
rvol = volume / vol_ma
rvol_ok = not use_rvol or (rvol > rvol_thresh)

// ORB Range
var float orb_high = na
var float orb_low = na
var int trades_today = 0

// Reset Daily
if ta.change(time("D"))
    orb_high := na
    orb_low := na
    trades_today := 0

if (hour == orb_start_hour and minute == orb_start_minute)
    orb_high := high
    orb_low := low
else if (hour == orb_start_hour and minute >= orb_start_minute and minute < orb_end_minute)
    orb_high := math.max(orb_high, high)
    orb_low := math.min(orb_low, low)

plot(orb_high, "Range High", color=color.green, style=plot.style_stepline)
plot(orb_low, "Range Low", color=color.red, style=plot.style_stepline)
plot(ema_val, "EMA", color=color.yellow)

// Entry Conditions
range_size = orb_high - orb_low
is_compressed = range_size < (atr_val * atr_max)
has_adx = adx_val > adx_threshold

// Trade Logic (1 per day)
long_cond = close > orb_high and close > ema_val and has_adx and is_compressed and is_session and strategy.position_size == 0 and trades_today == 0 and macro_trend_ok and rvol_ok
short_cond = close < orb_low and close < ema_val and has_adx and is_compressed and is_session and strategy.position_size == 0 and trades_today == 0 and macro_trend_ok and rvol_ok

// Execution
if (long_cond)
    strategy.entry("Long", strategy.long)
    strategy.exit("Exit Long", "Long", stop=close - (atr_val * sl_atr_mult), limit=close + (atr_val * tp_atr_mult))
    trades_today := trades_today + 1

if (short_cond)
    strategy.entry("Short", strategy.short)
    strategy.exit("Exit Short", "Short", stop=close + (atr_val * sl_atr_mult), limit=close - (atr_val * tp_atr_mult))
    trades_today := trades_today + 1

// EOD Flatten
if (hour == 15 and minute == 45)
    strategy.close_all(comment="EOD")
"""
        super().__init__(bars, events)
        self.orb_start = orb_start_time
        self.orb_end = orb_end_time
        self.exit_time = exit_time
        self.verbose = verbose
        
        # State
        self.orb_high = None
        self.orb_low = None
        self.current_date = None
        self.traded_today = False
        
        self.entry_price = None
        self.in_long = False
        self.in_short = False
        self.current_sl = 0
        self.current_tp = 0
        
        # Params
        self.sl_atr_mult = float(sl_atr_mult)
        self.tp_atr_mult = float(tp_atr_mult)
        self.ema_filter = int(ema_filter)
        self.atr_filter = int(atr_filter)
        self.adx_filter = float(adx_thresh if adx_thresh is not None else adx_filter)
        self.atr_max_mult = float(atr_max_mult)
        self.use_adx = use_adx
        self.use_macro_filter = use_macro_filter
        self.use_rvol = use_rvol
        self.rvol_thresh = float(rvol_thresh)
        self.use_chop_filter = False # params.get('use_chop_filter', False) - passed in kwargs usually
        self.chop_thresh = 61.8

    def set_advanced_filters(self, use_chop=False, chop_thresh=61.8):
        self.use_chop_filter = use_chop
        self.chop_thresh = chop_thresh

    def calculate_signals(self, event: Bar):
        symbol = event.symbol
        ts = event.timestamp
        current_time = ts.time()
        
        # 1. Reset Daily
        if self.current_date != ts.date():
            self.current_date = ts.date()
            self.orb_high = -float('inf')
            self.orb_low = float('inf')
            self.traded_today = False
            self.entry_price = None
            self.in_long = False
            self.in_short = False

        # 2. Build Range (9:30-9:45)
        if self.orb_start <= current_time < self.orb_end:
            self.orb_high = max(self.orb_high, event.high)
            self.orb_low = min(self.orb_low, event.low)
            return

        # 3. Indicators (Need History)
        # 5200 ~= 200 daily bars * 26 (15m bars per 6.5h session)
        req_history = 5500 if self.use_macro_filter else (max(self.ema_filter, self.atr_filter) + 100)
        bars = self.bars.get_latest_bars(symbol, N=req_history)
        if len(bars) < max(self.ema_filter, self.atr_filter) + 5: return
        
        from src.backtesting import ta
        df = pd.DataFrame([{'close': b.close, 'high': b.high, 'low': b.low, 'volume': b.volume} for b in bars])
        
        ema = ta.ema(df['close'], length=self.ema_filter).iloc[-1]
        atr = ta.atr(df['high'], df['low'], df['close'], length=self.atr_filter).iloc[-1]
        adx = ta.adx(df['high'], df['low'], df['close'], length=14).iloc[-1]
        
        # Macro Trend (Proxy: 200 Daily SMA ~= 5200 bars on 15m)
        lt_sma = 0
        macro_ok = True
        if self.use_macro_filter:
            if len(df) >= 5200:
                lt_sma = ta.sma(df['close'], length=5200).iloc[-1]
                macro_ok = event.close > lt_sma
            else:
                macro_ok = False # Not enough data typically means early in backtest

        # RVOL
        vol_ma = 0
        rvol_ok = True
        if self.use_rvol:
             if len(df) >= 20:
                 vol_ma = ta.sma(df['volume'], length=20).iloc[-1]
                 if vol_ma > 0:
                     rvol = df['volume'].iloc[-1] / vol_ma
                     rvol_ok = rvol > self.rvol_thresh

        # Choppiness
        chop_ok = True
        if self.use_chop_filter:
             if len(df) >= 20: # Needs at least 14 + buffer
                 chop_val = ta.chop_index(df['high'], df['low'], df['close'], length=14).iloc[-1]
                 chop_ok = chop_val < self.chop_thresh

        # 4. Entry Logic (9:45 - 15:45)
        if self.orb_end <= current_time < self.exit_time:
            if not self.traded_today:
                range_size = self.orb_high - self.orb_low
                is_compressed = range_size <= (atr * self.atr_max_mult)
                has_adx = adx > self.adx_filter
                
                # Valid Range Check
                if self.orb_high == -float('inf'): return 

                # Long
                if event.close > self.orb_high and event.close > ema and is_compressed and has_adx and macro_ok and rvol_ok and chop_ok:
                     if self.verbose: 
                         print(f"[{ts}] LONG ENTRY @ {event.close}")
                     self.buy(symbol, 1)
                     self.traded_today = True
                     self.in_long = True
                     self.entry_price = event.close
                     self.current_sl = atr * self.sl_atr_mult
                     self.current_tp = atr * self.tp_atr_mult
                
                # Short
                elif event.close < self.orb_low and event.close < ema and is_compressed and has_adx and macro_ok and rvol_ok and chop_ok:
                     if self.verbose:
                         print(f"[{ts}] SHORT ENTRY @ {event.close}")
                     self.sell(symbol, 1)
                     self.traded_today = True
                     self.in_short = True
                     self.entry_price = event.close
                     self.current_sl = atr * self.sl_atr_mult
                     self.current_tp = atr * self.tp_atr_mult

            # 5. Management
            elif self.in_long:
                 if event.low < (self.entry_price - self.current_sl):
                     self.exit(symbol)
                     self.in_long = False
                 elif event.high > (self.entry_price + self.current_tp):
                     self.exit(symbol)
                     self.in_long = False
            elif self.in_short:
                 if event.high > (self.entry_price + self.current_sl):
                     self.exit(symbol)
                     self.in_short = False
                 elif event.low < (self.entry_price - self.current_tp):
                     self.exit(symbol)
                     self.in_short = False

        # 6. EOD
        if current_time >= self.exit_time:
            if self.in_long or self.in_short:
                self.exit(symbol)
                self.in_long = False
                self.in_short = False
