"""
Code validation utilities for LLM-generated strategy code.

This module provides functions to validate, fix, and sanitize Python code
generated by LLM agents before execution, preventing common errors like
missing imports and syntax issues.
"""
import ast
import re
from typing import Tuple, List, Optional, Set


# Required imports that should be present in every generated strategy
REQUIRED_IMPORTS_TEMPLATE = """
import pandas as pd
import numpy as np
import sys
import os
from datetime import datetime, time
from queue import Queue
import warnings
warnings.filterwarnings('ignore')
"""

# Set of commonly used module names that should be imported
COMMON_MODULES = {
    'pandas', 'numpy', 'datetime', 'time', 'sys', 'os', 'queue', 'warnings'
}


def validate_syntax(code: str) -> Tuple[bool, Optional[str]]:
    """
    Validate Python syntax using AST parsing.

    Args:
        code: Python source code string

    Returns:
        Tuple of (is_valid, error_message)
        - is_valid: True if code has valid Python syntax
        - error_message: None if valid, otherwise the syntax error description
    """
    try:
        ast.parse(code)
        return True, None
    except SyntaxError as e:
        return False, f"Syntax error at line {e.lineno}: {e.msg}"
    except Exception as e:
        return False, f"Parsing error: {str(e)}"


def extract_imports(code: str) -> Set[str]:
    """
    Extract all imported module names from code.

    Args:
        code: Python source code string

    Returns:
        Set of imported module names (top-level only)
    """
    imports = set()
    try:
        tree = ast.parse(code)
        for node in ast.walk(tree):
            if isinstance(node, ast.Import):
                for alias in node.names:
                    # Get top-level module name
                    imports.add(alias.name.split('.')[0])
            elif isinstance(node, ast.ImportFrom):
                if node.module:
                    imports.add(node.module.split('.')[0])
    except SyntaxError:
        # Code has syntax errors - can't extract imports via AST
        # Fall back to regex-based extraction
        import_pattern = r'^(?:import\s+(\w+)|from\s+(\w+)\s+import)'
        for match in re.finditer(import_pattern, code, re.MULTILINE):
            module = match.group(1) or match.group(2)
            if module:
                imports.add(module)
    except Exception:
        # Other parsing errors - return empty set
        pass
    return imports


def extract_used_names(code: str) -> Set[str]:
    """
    Extract all names used in the code.

    Args:
        code: Python source code string

    Returns:
        Set of names used (function calls, variable references)
    """
    names = set()
    try:
        tree = ast.parse(code)
        for node in ast.walk(tree):
            if isinstance(node, ast.Name):
                names.add(node.id)
            elif isinstance(node, ast.Attribute):
                # Get the root name (e.g., 'pd' from 'pd.DataFrame')
                current = node
                while isinstance(current, ast.Attribute):
                    current = current.value
                if isinstance(current, ast.Name):
                    names.add(current.id)
    except SyntaxError:
        # Code has syntax errors - fall back to regex-based extraction
        # Look for common module prefixes like pd., np., os., sys., etc.
        module_patterns = [
            r'\bpd\.',       # pandas
            r'\bnp\.',       # numpy
            r'\bos\.',       # os
            r'\bsys\.',      # sys
            r'\bjson\.',     # json
            r'\bre\.',       # re
            r'\bglob\.',     # glob
            r'\bwarnings\.', # warnings
            r'\btime\.',     # time module
        ]
        for pattern in module_patterns:
            if re.search(pattern, code):
                module_name = pattern.replace(r'\b', '').replace(r'\.', '')
                names.add(module_name)
    except Exception:
        # Other parsing errors - return empty set
        pass
    return names


def check_datetime_import(code: str) -> Tuple[bool, str]:
    """
    Check for common datetime import mistakes.

    The LLM often writes `import time` (the standard library module) when
    it should use `from datetime import time` for time objects like time(9, 30).

    Args:
        code: Python source code string

    Returns:
        Tuple of (is_valid, corrected_code_or_original)
        - is_valid: True if no fix needed
        - corrected_code: The fixed code if needed, otherwise original
    """
    # Pattern: code uses time(hour, minute) syntax, which requires datetime.time
    time_constructor_pattern = r'\btime\s*\(\s*\d+\s*,\s*\d+\s*\)'

    if re.search(time_constructor_pattern, code):
        # Check if proper import exists
        if 'from datetime import' in code and 'time' in code.split('from datetime import')[1].split('\n')[0]:
            # Correct import exists
            return True, code

        # Check if wrong import exists
        if re.search(r'^import\s+time\s*$', code, re.MULTILINE):
            # Has `import time` but uses time(h, m) which needs datetime.time
            # Fix: Replace import and usage
            fixed_code = re.sub(
                r'^import\s+time\s*$',
                'from datetime import time as _dt_time\nimport time as _time_module',
                code,
                flags=re.MULTILINE
            )
            # Also need to differentiate usages - time.sleep() vs time(9, 30)
            # This is tricky. Simpler: just add the datetime import at top
            fixed_code = "from datetime import time\n" + code
            return False, fixed_code

        # No time import at all but uses time()
        fixed_code = "from datetime import time\n" + code
        return False, fixed_code

    return True, code


def validate_required_imports(code: str) -> Tuple[bool, List[str]]:
    """
    Check if commonly required imports are present.

    Args:
        code: Python source code string

    Returns:
        Tuple of (all_present, list_of_missing_imports)
    """
    imports = extract_imports(code)
    used_names = extract_used_names(code)
    missing = []

    # Check for pandas
    if 'pd' in used_names and 'pandas' not in imports:
        missing.append('pandas')

    # Check for numpy
    if 'np' in used_names and 'numpy' not in imports:
        missing.append('numpy')

    # Check for datetime/time
    if 'time' in used_names or 'datetime' in used_names:
        if 'datetime' not in imports:
            missing.append('datetime')

    # Check for Queue
    if 'Queue' in used_names and 'queue' not in imports:
        missing.append('queue')

    # Check for warnings
    if 'warnings' in used_names and 'warnings' not in imports:
        missing.append('warnings')

    # Check for sys - commonly used for path manipulation
    if 'sys' in used_names and 'sys' not in imports:
        missing.append('sys')

    # Check for os - commonly used for path operations
    if 'os' in used_names and 'os' not in imports:
        missing.append('os')

    # Check for glob - commonly used for file finding
    if 'glob' in used_names and 'glob' not in imports:
        missing.append('glob')

    # Check for json - commonly used for data
    if 'json' in used_names and 'json' not in imports:
        missing.append('json')

    # Check for re - commonly used for regex
    if 're' in used_names and 're' not in imports:
        missing.append('re')

    return len(missing) == 0, missing


def inject_missing_imports(code: str, missing: List[str]) -> str:
    """
    Add missing imports to the top of the code.

    Args:
        code: Python source code string
        missing: List of missing module names

    Returns:
        Code with missing imports added at the top
    """
    import_lines = []

    # Define specific import statements for common modules
    import_statements = {
        'pandas': 'import pandas as pd',
        'numpy': 'import numpy as np',
        'datetime': 'from datetime import datetime, time',
        'queue': 'from queue import Queue',
        'warnings': 'import warnings',
        'sys': 'import sys',
        'os': 'import os',
        'glob': 'import glob',
        'json': 'import json',
        're': 'import re',
        'time_module': 'import time',  # For time.sleep() etc.
        'math': 'import math',
        'collections': 'from collections import deque, defaultdict',
        'typing': 'from typing import List, Dict, Optional, Tuple, Any',
    }

    for module in missing:
        if module in import_statements:
            import_lines.append(import_statements[module])
        else:
            import_lines.append(f'import {module}')

    if import_lines:
        return '\n'.join(import_lines) + '\n\n' + code

    return code


def remove_markdown_artifacts(code: str) -> str:
    """
    Remove markdown code block markers and LLM preamble text.

    Args:
        code: Potentially messy LLM output

    Returns:
        Cleaned Python code
    """
    # Remove markdown code blocks
    code = code.replace("```python", "").replace("```", "")

    # Remove common LLM preamble patterns
    preamble_patterns = [
        r"^Here'?s?\s+(?:the|my|your|an?).*?(?:code|implementation|solution).*?:\s*\n*",
        r"^.*?modified.*?(?:code|version).*?:\s*\n*",
        r"^.*?updated.*?(?:code|version).*?:\s*\n*",
        r"^.*?improved.*?(?:code|version).*?:\s*\n*",
        r"^I've\s+(?:made|added|updated|fixed).*?:\s*\n*",
        r"^Below\s+is.*?:\s*\n*",
        r"^The\s+following.*?:\s*\n*",
    ]

    for pattern in preamble_patterns:
        code = re.sub(pattern, "", code, flags=re.IGNORECASE | re.MULTILINE)

    # Remove trailing explanations after the code
    # Look for patterns like "This code does..." after a class/function definition ends
    trailing_patterns = [
        r'\n\nThis\s+(?:code|implementation|function|class).*$',
        r'\n\nNote:.*$',
        r'\n\nExplanation:.*$',
        r'\n\n---.*$',
    ]

    for pattern in trailing_patterns:
        code = re.sub(pattern, "", code, flags=re.IGNORECASE | re.DOTALL)

    return code.strip()


def ensure_code_starts_with_imports(code: str) -> str:
    """
    Ensure the code starts with import statements, not other text.

    Args:
        code: Python code that might have leading text

    Returns:
        Code starting from the first import statement
    """
    lines = code.split('\n')

    # Find first line that looks like valid Python (import, from, def, class, #, """)
    start_patterns = [
        r'^import\s+',
        r'^from\s+',
        r'^def\s+',
        r'^class\s+',
        r'^#',
        r'^"""',
        r"^'''",
        r'^@',  # Decorator
    ]

    for i, line in enumerate(lines):
        stripped = line.strip()
        if not stripped:
            continue
        for pattern in start_patterns:
            if re.match(pattern, stripped):
                return '\n'.join(lines[i:])

    # If no valid start found, return as-is
    return code


def validate_and_fix_code(code: str) -> Tuple[bool, str, List[str]]:
    """
    Full validation and auto-fix pipeline for LLM-generated code.

    This function performs multiple validation steps and attempts to
    automatically fix common issues:
    1. Remove markdown artifacts
    2. Ensure code starts with imports
    3. Check and fix datetime import issues
    4. Check and inject missing required imports
    5. Final syntax validation

    Args:
        code: Raw LLM-generated code

    Returns:
        Tuple of (is_valid, fixed_code, list_of_issues)
        - is_valid: True if code is valid after fixes
        - fixed_code: The corrected code
        - issues: List of issues found/fixed (for logging)
    """
    issues = []

    # Step 1: Clean up markdown and preamble
    original_code = code
    code = remove_markdown_artifacts(code)
    if code != original_code:
        issues.append("Removed markdown artifacts")

    # Step 2: Ensure starts with valid Python
    cleaned = ensure_code_starts_with_imports(code)
    if cleaned != code:
        issues.append("Trimmed leading non-code text")
        code = cleaned

    # Step 3: Initial syntax check
    is_valid, error = validate_syntax(code)
    if not is_valid:
        issues.append(f"Syntax error: {error}")
        # Can't auto-fix syntax errors - return early
        return False, code, issues

    # Step 4: Check datetime import issue
    dt_valid, code = check_datetime_import(code)
    if not dt_valid:
        issues.append("Fixed datetime.time import")

    # Step 5: Check required imports
    imports_valid, missing = validate_required_imports(code)
    if not imports_valid:
        code = inject_missing_imports(code, missing)
        issues.append(f"Added missing imports: {missing}")

    # Step 6: Final syntax check after modifications
    is_valid, error = validate_syntax(code)
    if not is_valid:
        issues.append(f"Post-fix syntax error: {error}")
        return False, code, issues

    return True, code, issues


def create_strategy_template(class_name: str = "GeneratedStrategy") -> str:
    """
    Create a basic strategy template with all required imports.

    Args:
        class_name: Name for the generated strategy class

    Returns:
        Template code string
    """
    return f'''"""
Auto-generated trading strategy.
"""
import pandas as pd
import numpy as np
import sys
import os
from datetime import datetime, time
from queue import Queue
import warnings
warnings.filterwarnings('ignore')

# Add parent path for imports
sys.path.insert(0, os.path.dirname(os.path.dirname(os.path.abspath(__file__))))


class {class_name}:
    """
    Generated Strategy Class.

    Implement calculate_signals() to generate trading signals.
    """

    def __init__(self, data_handler, events, **params):
        self.bars = data_handler
        self.events = events
        self.params = params

    def calculate_signals(self, event):
        """
        Generate signals based on market data.

        Args:
            event: Bar event with OHLCV data

        Returns:
            Signal (1=LONG, -1=SHORT, 0=FLAT)
        """
        # TODO: Implement strategy logic
        pass
'''


def get_validation_prompt_suffix() -> str:
    """
    Get prompt suffix that instructs LLM on proper code formatting.

    Returns:
        String to append to code generation prompts
    """
    return """
CRITICAL CODE REQUIREMENTS:
1. Start with these EXACT imports at the very top:
   ```python
   import pandas as pd
   import numpy as np
   from datetime import datetime, time
   from queue import Queue
   import warnings
   warnings.filterwarnings('ignore')
   ```

2. Use `time(9, 30)` for time objects - this is `datetime.time`, NOT the `time` module

3. Return ONLY valid Python code. No explanations, no markdown.

4. Ensure all classes inherit properly and all methods have correct signatures.
"""
